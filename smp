#!/usr/bin/env python
import glob
import os
import re
from pathlib import Path
from select import select  # for non-blocking input, Unix only
from sys import stdin, platform
import smp_queue as q
from smp_queue import Player, queue
from smp_common import *
from smp_help import ihelp
from settings import *
from time import sleep

import mutagen  # for getting song duration
import pygame
from pygame import mixer
from pygame.mixer import music

CONFIG_PATH = Path("~/.config/smp/smp.conf").expanduser()
SUPPORTED_TYPES = ["mp3", "ogg", "wav", "flac", "opus"]
CMDS = {
    "play": lambda *args: play(*args),
    "stop": lambda *args: stop(),
    "volume": lambda *args: volume(*args),
    "ls": lambda *args: ls(*args),
    "list": lambda *args: ls(*args),
    "loop": lambda *args: loop(),
    "time": lambda *args: time(),
    "rewind": lambda *args: seek_relative(*args),
    "repeat": lambda *args: repeat(*args),
    "forward": lambda *args: seek_relative(*args, forward=True),
    "seek": lambda *args: seek_absolute(*args),
    "pause": lambda *args: pause(),
    "unpause": lambda *args: unpause(),
    "queue": lambda *args: queue(*args),
    "macro": lambda *args: add_macro(*args),
    "help": lambda *args: ihelp(*args),
    "exit": lambda *args: smp_exit(),
    "quit": lambda *args: smp_exit(),
    "config": lambda *args: config(*args),
    "eval": lambda arg: print(eval(arg)),
    # For debug only, exceptions are not handled
}


def add_macro(*args, macros):
    if not args:
        return
    mcr, *args = args
    if mcr in CMDS:
        print("Macros can't be named existing commands")
        return
    if not args:
        print("Macro needs at least one argument")
        return
    macros[mcr] = " ".join(args)


def is_valid_cmd(cmd, cmd_set):
    commands = [c for c in cmd_set if c.startswith(cmd)]
    if len(commands) == 1:
        return commands[0]


def should_repeat():
    if not (music.get_busy() or Player.should_pause) and Player.repeats:
        Player.repeats -= 1
        return True


def repeat(*args):
    if not args:
        Player.repeats = 1
        return
    repeats = type_converter(args[0], int, "Repeats must be an integer")
    if not isinstance(repeats, int) or repeats < 1:
        return
    Player.repeats = repeats


if platform == "win32":
    import msvcrt

    def input_entered(string=[""]):
        if msvcrt.kbhit():
            ch = msvcrt.getch()
            if ch in (b"\x00", b"\xe0"):
                msvcrt.getch()
            if ch == b"\x08":
                if len(string[0]) != 0:
                    string[0] = string[0][:-1]
                    print(end="\b \b", flush=True)
            elif ch != b"\r":
                string[0] += ch.decode()
                print(end=ch.decode(), flush=True)
            else:
                res = string[0]
                print()
                if not res:
                    print(end=Settings.prompt, flush=True)
                string[0] = ""
                return res
else:

    def input_entered():
        # Check if user has entered a newline
        # and return stdin if true
        # (from docs)
        # IMPORTANT NOTICE
        # On Windows, only sockets are supported; on Unix, all file
        # descriptors can be used.
        stdin_is_ready = select([stdin], [], [], 0)[0]
        if stdin_is_ready:
            return stdin_is_ready[0].readline().strip()
        return False


def clamp(num, low, high):
    return min(max(num, low), high)


def type_converter(data, type_, err_msg):
    try:
        return type_(data)
    except ValueError:
        print(err_msg)


def parse_input(string):
    commands = string.strip(";").split(";")
    # str.split is insufficient for our needs as we need to be able to parse
    # strings with spaces in them
    out = []
    accumulator = ""
    quoted = False
    for i, command in enumerate(commands):
        out.append([])
        for idx, ch in enumerate(command):
            if ch in ('"', "'"):
                quoted ^= True
            elif ch == " ":
                if quoted:
                    accumulator += ch
                else:
                    if accumulator:
                        out[i].append(accumulator.strip())
                        accumulator = ""
            else:
                accumulator += ch
        out[i].append(accumulator.strip())
        accumulator = ""
    return out


def play(*args):
    if not args:
        print("expected at least one argument")
        return
    Player.loops = 0
    Player.offset = 0
    Player.should_pause = False
    if len(args) >= 1:
        song = args[0]
    if len(args) >= 2:
        Player.volume = type_converter(
            args[1], float, "Volume needs to be between 0 and 100"
        )
    if len(args) >= 3:
        Player.loops = type_converter(
            args[2], int, "Number of loops must be an integer"
        )
    if Player.volume is None or Player.loops is None:
        return

    try:
        music.load(Settings.music_dir / song)
    except (pygame.error, FileNotFoundError):
        file = song
        song = ac_songs(Settings.autocomplete, song)
        if not song:
            return
        else:
            Player.playing_queue = False
            music.load(Settings.music_dir / song)
    if Settings.music_dir / song != Player.cur_song:
        Player.repeats = 0
    Player.cur_song = Settings.music_dir / song
    music.set_volume(Player.volume / 100)
    music.play(Player.loops)
    should_pause = False
    file = mutagen.File(Player.cur_song)
    Player.duration = file.info.length


def volume(*args):
    if not args:
        print(f"Volume: {Player.volume}%")
    elif len(args) == 1:
        Player.volume = type_converter(
            args[0], float, "Volume needs to be between 0 and 100"
        )
        music.set_volume(Player.volume / 100)


def ls(*args):
    files = gen_files()
    files.sort()
    humanized = [song[: song.index(".")] for song in files]
    ls_args = []
    arg_str = ""
    for arg in args:
        if arg.startswith("-"):
            if arg[1:].isdigit():
                # Don't confuse negative numbers with flags
                arg_str += arg.strip()
                continue
            if arg_str:
                ls_args.append(arg_str)
                arg_str = ""
            ls_args.append(arg)
        else:
            arg_str += arg.strip()
    if arg_str:
        ls_args.append(arg_str)
    if len(ls_args) % 2 != 0:
        print("Malformed arguments")
        return
    i_arg = iter(ls_args)
    while True:
        idxs = slice(len(humanized))
        try:
            flag, val = next(i_arg), next(i_arg)
            flag = flag.lower()
        except StopIteration:
            break
        if flag not in ("-s", "-n"):
            print(f"Invalid flag {flag}")
            continue
        if flag == "-n":
            vals = list(map(lambda x: int(str.strip(x)), val.split(",")))
            idxs = slice(*vals)
            humanized = humanized[idxs]
        elif flag == "-s":
            tmp = []
            found = False
            for song in humanized:
                if not song.startswith(val):
                    if not found:
                        continue
                    break
                tmp.append(song)
                found = True
            humanized = tmp
            del tmp
    print(Settings.ls_sep.join(humanized))


def loop():
    if Player.loops > 0:
        Player.loops = 0
    Player.loops = ~Player.loops
    if Player.loops:
        print("Loop: on")
    else:
        print("Loop: off")
    start = music.get_pos() / 1000
    if music.get_busy() or Player.should_pause:
        music.pause()
        music.play(Player.loops, (start + Player.offset) % Player.duration)
        Player.offset += start
    if Player.should_pause:
        music.pause()


def time():
    if Player.duration == 0:
        print("Nothing playing")
        return
    cur_time = music.get_pos() / 1000 + Player.offset
    time = cur_time % Player.duration
    if not music.get_busy():
        if not Player.should_pause or (abs(time - Player.duration)) < 0.5:
            print("Nothing playing")
            return
    print(
        f"{timestamp(int(time))} elapsed, "
        f"{timestamp(int(Player.duration - time))} remaining"
    )


def seek_relative(*args, forward=False):
    if not args:
        print("Expected either a number in seconds or a timestamp")
        return
    if not Player.duration:
        print("Nothing playing")
        return
    start = music.get_pos() / 1000 + Player.offset
    secs = args[0]
    try:
        float(secs)
    except ValueError:
        secs = timestamp_as_num(secs)
        if not secs:
            print("Expected either a number in seconds or a timestamp")
            return
    if not forward:
        time = clamp(float(secs), 0, start)
        Player.offset = new_time = start - time
    else:
        time = clamp(float(secs), 0, Player.duration - start - 0.1)
        Player.offset = new_time = start + time
    new_time %= Player.duration
    Player.offset %= Player.duration
    music.pause()
    music.play(Player.loops, new_time)
    if Player.should_pause:
        music.pause()


def seek_absolute(*args):
    if not args:
        print("Expected either a number in seconds or a timestamp")
        return
    if not Player.duration:
        print("Nothing playing")
        return
    time = args[0]
    try:
        float(time)
    except ValueError:
        time = timestamp_as_num(time)
        if not time:
            print("Expected either a number in seconds or a timestamp")
            return
    time = clamp(float(time), 0, Player.duration - 0.1)
    Player.offset = time
    music.pause()
    music.play(Player.loops, time)
    if Player.should_pause:
        music.pause()


def pause():
    Player.should_pause = ~Player.should_pause
    if Player.should_pause:
        music.pause()
    else:
        music.unpause()


def stop():
    music.stop()
    music.unload()
    Player.cur_song = ""
    Player.playing_queue = False


def unpause():
    music.unpause()
    should_pause = False


def smp_exit():
    music.unload()
    mixer.quit()
    exit(0)


def timestamp_as_num(ts):
    secs = 0
    hms = re.compile(r"^[1-9]{1,2}:[0-5][0-9]:[0-5][0-9]$")
    ms = re.compile(r"^[0-5][0-9]?:[0-5][0-9]$")
    if re.match(hms, ts) or re.match(ms, ts):
        ts = ts.split(":")
        ts.reverse()
        ts = list(map(int, ts))
        for idx, num in enumerate(ts):
            secs += num * (60**idx)
        return secs


def parse_and_execute(cmd, cmd_set):
    cmd = cmd.replace(";;", ";")
    commands = parse_input(cmd)
    for command in commands:
        cmd, *args = command
        if not cmd:
            continue
        if cmd in cmd_set:
            cmd_set[cmd](*args)
        else:
            autocomplete(Settings.autocomplete, cmd, cmd_set, *args)


def main():
    macros = {}
    Settings.read_config(parser.get_config(CONFIG_PATH))
    cfg_last_modified = CONFIG_PATH.stat().st_mtime
    mixer.init()
    failed_calls = 0
    print(end=Settings.prompt, flush=True)
    while True:
        try:
            cfg_mtime = os.stat(CONFIG_PATH).st_mtime
            failed_calls = 0
        except FileNotFoundError:
            failed_calls += 1
            # Sometimes the config file is not recognized,
            # so we just need to wait.
            if failed_calls > 10000:
                print("CRITICAL: Config file not found!")
                config(generate=True)
                # Other times it really doesn't exist, likely because
                # it's been moved or deleted
            continue
        if cfg_mtime != cfg_last_modified:
            reload_cfg(startup=False)  # Hot reloading
            cfg_last_modified = cfg_mtime
        sleep(0.01)
        # Drastically reduces CPU usage with almost no performance hit
        if should_repeat():
            play(Player.cur_song)
        if q.should_advance():
            q.play()
        command = input_entered()
        if command is False:
            continue
        elif not command:
            print(end=Settings.prompt, flush=True)
            continue
        else:
            cmd, *args = command.split()
            if is_valid_cmd(cmd, CMDS) == "macro":
                add_macro(*args, macros=macros)
                print(end=Settings.prompt, flush=True)
                continue
            commands = " ".join((cmd, *args)).split(";")
            for cmd in commands:
                cmd = cmd.strip()
                if len(cmd.split()) > 1:
                    cmd, *args = cmd.split()
                if is_valid_cmd(cmd, CMDS):
                    if args:
                        parse_and_execute(f"{cmd} {' '.join(args)}", CMDS)
                    else:
                        parse_and_execute(cmd, CMDS)
                elif mcr := is_valid_cmd(cmd, macros):
                    parse_and_execute(macros[mcr], CMDS)
                else:
                    autocomplete(Settings.autocomplete, cmd, CMDS, *args)
            print(end=Settings.prompt, flush=True)
            continue


if __name__ == "__main__":
    main()
