#!/usr/bin/env python
import glob
import os
import parser
from pathlib import Path
from select import select  # for non-blocking input, Unix only
from sys import stdin
import smp_queue as q
from smp_queue import Settings, Player, queue
from smp_ux import *
from time import sleep

import mutagen  # for getting song duration
import pygame
from pygame import mixer
from pygame.mixer import music


def input_entered(prompt):
    # Check if user has entered a newline
    # and return stdin if true
    # (from docs)
    # IMPORTANT NOTICE
    # On Windows, only sockets are supported; on Unix, all file
    # descriptors can be used.
    stdin_is_ready = select([stdin], [], [], 0)[0]
    if stdin_is_ready:
        return stdin_is_ready[0]
    return False


def guess_ext(song):
    # Allows user to omit file extension as long
    # as the file is in a format that Pygame supports
    for ext in SUPPORTED_TYPES:
        if (file := f"{song}.{ext}") in FILES:
            return file
    else:
        return False


def config(*args, generate=False):
    if generate or not CONFIG_PATH.exists():
        print("Generating default configuration file...")
        if not CONFIG_PATH.parent.exists():
            os.mkdir(CONFIG_PATH.parent)
        if CONFIG_PATH.exists():
            os.remove(CONFIG_PATH)
        with open(CONFIG_PATH, "x") as f:
            f.write(
                """[General]
# Path to all your songs and playlists
music_dir = ~/music
playlist_dir = ~/music/playlists
# Also equivalent to %(music_dir)s/playlists

# By default, this prompt should look like a music note.
# If it doesn't, either replace it or consider using a patched font.
prompt = ' '

autocomplete = 1
# 0 - No autocomplete (not recommended)
# 1 - Unambiguous autocomplete (default)
# 2 - Full autocomplete: If your input is ambiguous, smp will list
# all possible commands and let you choose

default_volume = 80
# Sets the starting volume. Must be between 0 and 100

ls_sep = ", "
# Controls how `ls` separates each element of output. Setting this to
# " " allows you to use its output directly without having to remove commas
"""
            )
        print(f"Config file created in {CONFIG_PATH}")
        return
    if not args:
        with open(CONFIG_PATH) as f:
            print(f"Config file located in {CONFIG_PATH}")
            print(f.read())
            return
    cmd, *_ = args
    if cmd == generate:
        config(generate=True)


def clamp(num, low, high):
    return min(max(num, low), high)


def timestamp(num):
    mins, secs = divmod(num, 60)
    if mins > 60:
        hours, mins = divmod(mins, 60)
        return f"{hours}:{mins:02}:{secs:02}"
    return f"{mins}:{secs:02}"


def type_converter(data, type_, err_msg):
    try:
        return type_(data)
    except ValueError:
        print(err_msg)


def parse_input(string):
    # str.split is insufficient for our needs as we need to be able to parse
    # strings with spaces in them
    out = []
    accumulator = ""
    quoted = False
    for idx, ch in enumerate(string):
        if ch == " " and not quoted:
            # don't split by space if we are in quotes or the preceding
            # character was '\'
            if string[idx - 1] == "\\":
                accumulator += ch
                continue
            if accumulator:
                out.append(accumulator.strip())
                accumulator = ""
        elif ch == '"':
            quoted ^= True
            if not quoted:
                out.append(accumulator.strip())
                accumulator = ""
        elif ch == "\\":
            continue
        else:
            accumulator += ch
    if accumulator:
        out.append(accumulator.strip())
    return out


def flatten(lst):
    for elem in lst:
        if isinstance(elem, list):
            yield from flatten(elem)
        else:
            yield elem


def reload_cfg(startup=True):
    Settings.read_config(
        parser.get_config("/home/andrewsj05/.config/smp/smp.conf"), startup
    )


def reload_songs():
    global FILES
    FILES = list(
        map(
            lambda f: Path(f).name,
            flatten(
                [
                    glob.glob(f"{Settings.music_dir}/*.{ext}")
                    for ext in SUPPORTED_TYPES
                ]
            ),
        )
    )
    FILES.sort()


CONFIG_PATH = Path("~/.config/smp/smp.conf").expanduser()
Settings.read_config(parser.get_config(CONFIG_PATH))
SUPPORTED_TYPES = ["mp3", "ogg", "wav", "flac", "opus"]
FILES = list(
    map(
        lambda f: Path(f).name,
        flatten(
            [
                glob.glob(f"{Settings.music_dir}/*.{ext}")
                for ext in SUPPORTED_TYPES
            ]
        ),
    )
)
FILES.sort()
Q_CMDS = {
    "add": lambda *args: q.add(*args),
    "clear": lambda: q.clear(),
    "remove": lambda *args: q.remove(*args),
    "play": lambda: q.play(),
    "next": lambda: q.next(),
    "prev": lambda: q.prev(),
    "loop": lambda: q.loop(),
    "swap": lambda *args: q.swap(*args),
    "shuffle": lambda: q.shuffle(),
    "randomize": lambda: q.randomize(),
    "save": lambda *args: q.save(*args),
    "load": lambda *args: q.load(*args),
    "status": lambda: q.status(),
}
CMDS = {
    "play": lambda *args: play(*args),
    "stop": lambda: stop(),
    "volume": lambda *args: volume(*args),
    "ls": lambda *args: ls(*args),
    "list": lambda *args: ls(*args),
    "loop": lambda: loop(),
    "time": lambda: time(),
    "rewind": lambda *args: seek_relative(*args),
    "forward": lambda *args: seek_relative(*args, forward=True),
    "pause": lambda: pause(),
    "unpause": lambda: unpause(),
    "queue": lambda *args: queue(*args),
    "reload": lambda: reload_cfg(),
    "help": lambda: smp_help(),
    "exit": lambda: smp_exit(),
    "quit": lambda: smp_exit(),
    "config": lambda *args: config(*args),
    "eval": lambda arg: print(eval(arg)),
    # For debug only, exceptions are not handled
}


def play(*args):
    if not args:
        print("expected at least one argument")
        return
    Player.loops = 0
    Player.offset = 0
    Player.should_pause = False
    if len(args) >= 1:
        song = args[0]
    if len(args) >= 2:
        Player.volume = type_converter(
            args[1], float, "Volume needs to be between 0 and 100"
        )
    if len(args) >= 3:
        Player.loops = type_converter(
            args[2], int, "Number of loops must be an integer"
        )
    if Player.volume is None or Player.loops is None:
        return

    try:
        music.load(Settings.music_dir / song)
    except (pygame.error, FileNotFoundError):
        file = song
        song = guess_ext(song)
        if not song:
            print(f"Couldn't find {file} in {Settings.music_dir}")
            return
        else:
            music.load(Settings.music_dir / song)
    Player.cur_song = Settings.music_dir / song
    music.set_volume(Player.volume / 100)
    music.play(Player.loops)
    should_pause = False
    file = mutagen.File(Settings.music_dir / song)
    Player.duration = file.info.length


def volume(*args):
    if not args:
        print(f"Volume: {Player.volume}%")
    elif len(args) == 1:
        Player.volume = type_converter(
            args[0], float, "Volume needs to be between 0 and 100"
        )
        music.set_volume(Player.volume / 100)


def ls(*args):
    humanized = [song[: song.index(".")] for song in FILES]
    ls_args = []
    arg_str = ""
    for arg in args:
        if arg.startswith("-"):
            if arg[1:].isdigit():
                # Don't confuse negative numbers with flags
                arg_str += arg.strip()
                continue
            if arg_str:
                ls_args.append(arg_str)
                arg_str = ""
            ls_args.append(arg)
        else:
            arg_str += arg.strip()
    if arg_str:
        ls_args.append(arg_str)
    if len(ls_args) % 2 != 0:
        print("Malformed arguments")
        return
    i_arg = iter(ls_args)
    while True:
        idxs = slice(len(humanized))
        try:
            flag, val = next(i_arg), next(i_arg)
            flag = flag.lower()
        except StopIteration:
            break
        if flag not in ("-s", "-n"):
            print(f"Invalid flag {flag}")
            continue
        if flag == "-n":
            vals = list(map(lambda x: int(str.strip(x)), val.split(",")))
            idxs = slice(*vals)
            humanized = humanized[idxs]
        elif flag == "-s":
            tmp = []
            found = False
            for song in humanized:
                if not song.startswith(val):
                    if not found:
                        continue
                    break
                tmp.append(song)
                found = True
            humanized = tmp
            del tmp
    print(Settings.ls_sep.join(humanized))


def loop():
    if Player.loops > 0:
        Player.loops = 0
    Player.loops = ~Player.loops
    if Player.loops:
        print("Loop: on")
    else:
        print("Loop: off")
        return
    start = music.get_pos() / 1000
    if music.get_busy() or Player.should_pause:
        music.pause()
        music.play(Player.loops, (start + Player.offset) % Player.duration)
        Player.offset += start
    if Player.should_pause:
        music.pause()


def time():
    if Player.duration == 0:
        print("Nothing playing")
        return
    cur_time = music.get_pos() / 1000 + Player.offset
    time = cur_time % Player.duration
    if not music.get_busy():
        if not Player.should_pause or (abs(time - Player.duration)) < 0.5:
            print("Nothing playing")
            return
    print(
        f"{timestamp(int(time))} elapsed, "
        f"{timestamp(int(Player.duration - time))} remaining"
    )


def seek_relative(*args, forward=False):
    if not args:
        print("Expected a number in seconds")
        return
    if not music.get_busy():
        if not Player.should_pause:
            print("Nothing playing")
            return
    start = music.get_pos() / 1000 + Player.offset
    try:
        float(args[0])
    except ValueError:
        print("Expected a number in seconds")
        return
    if not forward:
        time = clamp(float(args[0]), 0, start)
        Player.offset = new_time = start - time
    else:
        time = clamp(float(args[0]), 0, Player.duration - start - 0.1)
        Player.offset = new_time = start + time
    new_time %= Player.duration
    Player.offset %= Player.duration
    music.pause()
    music.play(Player.loops, new_time)
    if Player.should_pause:
        music.pause()


def pause():
    Player.should_pause = ~Player.should_pause
    if Player.should_pause:
        music.pause()
    else:
        music.unpause()


def stop():
    music.stop()
    music.unload()
    Player.cur_song = ""
    Player.playing_queue = False


def unpause():
    music.unpause()
    should_pause = False


def smp_help():
    print(
        """TODO: I should really do something about that.
For now, check the source"""
    )


def smp_exit():
    music.unload()
    mixer.quit()
    exit(0)


def invalid_cmd():
    print("Command does not exist")


def main():
    cfg_last_modified = CONFIG_PATH.stat().st_mtime
    songs_last_modified = Settings.music_dir.stat().st_mtime
    mixer.init()
    print(end=Settings.prompt, flush=True)
    while True:
        try:
            cfg_mtime = os.stat(CONFIG_PATH).st_mtime
            songs_mtime = os.stat(Settings.music_dir).st_mtime
        except FileNotFoundError:
            # Sometimes the config file is not recognized,
            # so we just need to wait
            continue
        if cfg_mtime != cfg_last_modified:
            reload_cfg(startup=False)  # Hot reloading
            cfg_last_modified = cfg_mtime
        if songs_mtime != songs_last_modified:
            reload_songs()
            songs_last_modified = songs_mtime
        sleep(0.01)
        # Drastically reduces CPU usage with almost no performance hit
        choice = input_entered(Settings.prompt)
        if q.should_advance():
            q.play()
        if not choice:
            continue
        else:
            choice = parse_input(choice.readline().strip())
            if not choice:
                print(end=Settings.prompt, flush=True)
                continue
            cmd, *args = choice
            if cmd in CMDS:
                CMDS[cmd](*args)
            else:
                autocomplete(Settings.autocomplete, cmd, CMDS, *args)
            print(end=Settings.prompt, flush=True)
            continue


if __name__ == "__main__":
    main()
